<!DOCTYPE html><html lang="en"><head><title data-react-helmet="true">Requests with ReasonML</title><meta data-react-helmet="true" name="description" value="Front-end developer and designer. ReasonML, ReasonReact, ReactJS."/><meta data-react-helmet="true" charset="UTF-8"/><meta data-react-helmet="true" content="w75-P-0ywXWkyZvYPbkSM3VSM2hny25UrfeiWJt3B1k" name="google-site-verification"/><meta data-react-helmet="true" content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport"/><meta data-react-helmet="true" content="summary_large_image" name="twitter:card"/><meta data-react-helmet="true" content="website" property="og:type"/><meta data-react-helmet="true" content="https://bloodyowl.io/public/assets/images/share.jpg" property="og:image"/><meta data-react-helmet="true" content="https://bloodyowl.io/public/assets/images/share.jpg" name="twitter:image"/><meta data-react-helmet="true" content="@bloodyowl" name="twitter:site"/><meta data-react-helmet="true" content="1500" property="og:image:width"/><meta data-react-helmet="true" content="777" property="og:image:height"/><link data-react-helmet="true" href="/public/assets/images/favicon.png" rel="shortcut icon"/><link data-react-helmet="true" href="https://bloodyowl.io/blog/2019-01-20-requests-with-reasonml/" rel="canonical"/><style data-react-helmet="true" >@import url("//hello.myfonts.net/count/3cae5f")</style><script data-react-helmet="true" >window.beOpAsyncInit = function() {
        BeOpSDK.init({
          account: "556e1d2772a6b60100844051"
        });
        BeOpSDK.watch();
      };</script><script data-react-helmet="true" async="true" src="https://widget.beop.io/sdk.js"></script><script>window.PAGES_BOOT_MODE="hydrate";</script></head><div id="root"><style data-emotion-rpcss="lmebo p0hxbs 1sk4geg 12as1jd inii90 kk4a7b 16cj527 1moa3kc 18av5pk 1jtjujg j1f6xt a7hgs6 1h80fpx 1o4tcrz 68a2lg 1m2wep3 gghbgz 1dlwknq 1qdfdal">pre{padding:10px 20px;background-color:#F4F7F8;overflow-x:auto;-webkit-overflow-scrolling:touch;font-size:16px;border-left-width:2px;border-left-color:#46515B;border-left-style:solid;}@media (prefers-color-scheme:dark){pre{background-color:rgba(255,255,255,0.05);}}code{font-family:SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;font-size:0.85em;line-height:1;}.hljs-keyword{color:#DA6BB5;}.hljs-constructor{color:#DD792B;}.hljs-identifier{color:#1E9EA7;}.hljs-module-identifier{color:#C84682;}.hljs-string{color:#3BA1C8;}.hljs-comment{color:#aaa;}.hljs-operator{color:#DA6BB5;}.hljs-attribute{color:#4CB877;}table{width:100%;text-align:center;}table thead th{background-color:#E4EBEE;padding:10px 0;}blockquote{opacity:0.6;border-left:4px solid #46515B;margin:0;padding:0 20px;}@font-face{font-family:HelveticaNowDisplay;src:url("/public/assets/webfonts/regular.woff2"),url("/public/assets/webfonts/regular.woff");font-style:normal;font-weight:400;font-display:swap;}@font-face{font-family:HelveticaNowDisplay;src:url("/public/assets/webfonts/bold.woff2"),url("/public/assets/webfonts/bold.woff");font-style:normal;font-weight:700;font-display:swap;}body{padding:0;margin:0;background-color:#fff;font-family:HelveticaNowDisplay,"Helvetica Neue",Helvetica,Arial,sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;overflow-x:hidden;}@media (prefers-color-scheme:dark){body{background-color:#040404;}}#root{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}html{color:#46515B;font-size:1em;line-height:1.4;-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%;}@media (prefers-color-scheme:dark){html{color:#E4EBEE;}}*,*:before,*:after{box-sizing:border-box;}</style><style data-emotion-rpcss="1lm8k0f">.rpcss-1lm8k0f{min-height:100vh;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;}</style><div class="rpcss-1lm8k0f"><style data-emotion-rpcss="xn632j">.rpcss-xn632j{background-color:#E4EBEE;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}@media (prefers-color-scheme:dark){.rpcss-xn632j{background-color:#111;}}@media (max-width:620px){.rpcss-xn632j{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}</style><div class="rpcss-xn632j"><style data-emotion-rpcss="1ku00uy">.rpcss-1ku00uy{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;color:#46515B;-webkit-text-decoration:none;text-decoration:none;}@media (prefers-color-scheme:dark){.rpcss-1ku00uy{color:#E4EBEE;}}</style><a class="rpcss-1ku00uy" href="/"><style data-emotion-rpcss="19jaiin">.rpcss-19jaiin{margin-right:10px;margin-left:20px;-webkit-align-self:center;-ms-flex-item-align:center;align-self:center;}</style><img class="rpcss-19jaiin" alt="" height="32" src="/public/assets/images/owl.svg" width="32"/><style data-emotion-rpcss="16ucz1n">.rpcss-16ucz1n{padding:20px 20px 23px 0;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}</style><div aria-level="1" class="rpcss-16ucz1n" role="heading"><style data-emotion-rpcss="x6blf3">.rpcss-x6blf3{font-weight:700;margin-right:10px;white-space:nowrap;}</style><div class="rpcss-x6blf3">Matthias Le Brun</div><div>@bloodyowl</div></div></a><style data-emotion-rpcss="1qpr5ai">.rpcss-1qpr5ai{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}@media (max-width:620px){.rpcss-1qpr5ai{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:#D4E1E6;}}@media (max-width:620px) and (prefers-color-scheme:dark){.rpcss-1qpr5ai{background-color:#111;}}</style><div class="rpcss-1qpr5ai"><style data-emotion-rpcss="uy2dew">.rpcss-uy2dew{padding:20px 20px 23px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-text-decoration:none;text-decoration:none;color:#46515B;text-align:center;font-weight:700;}@media (prefers-color-scheme:dark){.rpcss-uy2dew{color:#E4EBEE;}}@media (max-width:620px){.rpcss-uy2dew{-webkit-flex-basis:33.333%;-ms-flex-preferred-size:33.333%;flex-basis:33.333%;padding:10px 20px 13px;}}</style><a class="rpcss-uy2dew" href="/blog/">Blog</a><style data-emotion-rpcss="1ppg9l3">.rpcss-1ppg9l3{padding:20px 20px 23px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-text-decoration:none;text-decoration:none;color:#46515B;text-align:center;}@media (prefers-color-scheme:dark){.rpcss-1ppg9l3{color:#E4EBEE;}}@media (max-width:620px){.rpcss-1ppg9l3{-webkit-flex-basis:33.333%;-ms-flex-preferred-size:33.333%;flex-basis:33.333%;padding:10px 20px 13px;}}</style><a class="rpcss-1ppg9l3" href="https://twitter.com/bloodyowl">Twitter</a><a class="rpcss-1ppg9l3" href="https://github.com/bloodyowl">GitHub</a></div></div><style data-emotion-rpcss="12z655i">.rpcss-12z655i{max-width:600px;padding:0 10px;margin:20px auto;width:100%;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}</style><div class="rpcss-12z655i"><style data-emotion-rpcss="apovzu">.rpcss-apovzu{margin:0;font-size:48px;margin-top:50px;margin-bottom:10px;line-height:1.15;}</style><h1 class="rpcss-apovzu">Requests with ReasonML</h1><style data-emotion-rpcss="12xm3b2">.rpcss-12xm3b2{font-size:14px;opacity:0.5;margin-bottom:50px;}</style><div class="rpcss-12xm3b2">2019/01/20</div><style data-emotion-rpcss="zhum8r">.rpcss-zhum8r{margin-top:40px;font-size:18px;}.rpcss-zhum8r a{color:#135EFF;}.rpcss-zhum8r a:hover{color:#13A3FF;}@media (prefers-color-scheme:dark){.rpcss-zhum8r a{color:#13A3FF;}}.rpcss-zhum8r img{max-width:100%;height:auto;}</style><div class="rpcss-zhum8r" role="article"><blockquote>
<p>This is how I choose to represent requests in my ReasonReact apps, there might be different ways that work well for you, but if this is something that you struggle with, that could be a good introduction to see how sum types can help you.</p>
</blockquote>
<p>Given there's no union type in JavaScript, we tend to use the following representation to store a request status in a component state</p>
<pre><code class="language-javascript"><span class="hljs-comment">/* pseudo code */</span>
type state(data, error) = {
  <span class="hljs-attr">isLoading</span>: bool,
  <span class="hljs-attr">error</span>: nullable(error),
  <span class="hljs-attr">data</span>: nullable(data)
};
</code></pre>
<p>and do something like this:</p>
<pre><code class="language-javascript">User.get(<span class="hljs-function">(<span class="hljs-params">error, data</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (error) {
    setState({ <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>, error });
  } <span class="hljs-keyword">else</span> {
    setState({ <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>, data });
  }
});
<span class="hljs-comment">/* or */</span>
User.get().then(
  <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> setState({ <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>, data }),
  <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> setState({ <span class="hljs-attr">isLoading</span>: <span class="hljs-literal">false</span>, error })
);
</code></pre>
<p>This pattern has two unfortunate consequences. The first one is that <strong>you can represent impossible states</strong> with it:</p>
<table>
<thead>
<tr><th>isLoading</th><th>error</th><th>data</th><th>Is possible?</th></tr>
</thead>
<tbody>
<tr><td><code>FALSE</code></td><td><code>NULL</code></td><td><code>NULL</code></td><td>✅</td></tr>
<tr><td><code>TRUE</code></td><td><code>NULL</code></td><td><code>NULL</code></td><td>✅</td></tr>
<tr><td><code>FALSE</code></td><td><code>ERROR</code></td><td><code>NULL</code></td><td>✅</td></tr>
<tr><td><code>TRUE</code></td><td><code>ERROR</code></td><td><code>NULL</code></td><td>❌</td></tr>
<tr><td><code>FALSE</code></td><td><code>NULL</code></td><td><code>DATA</code></td><td>✅</td></tr>
<tr><td><code>TRUE</code></td><td><code>NULL</code></td><td><code>DATA</code></td><td>❌</td></tr>
<tr><td><code>FALSE</code></td><td><code>ERROR</code></td><td><code>DATA</code></td><td>❌</td></tr>
<tr><td><code>TRUE</code></td><td><code>ERROR</code></td><td><code>DATA</code></td><td>❌</td></tr>
</tbody>
</table>
<p>The other one is that it makes you mix two different things:</p>
<ul>
<li>the request <strong>temporal</strong> status</li>
<li>the request <strong>success</strong> status</li>
</ul>
<h2>Representing the request status</h2>
<p>Typed functional language often have a <code>Result</code> or <code>Either</code> type. A result can be:</p>
<ul>
<li><code>Ok</code>, I have this data</li>
<li><code>Error</code>, here what's faield</li>
</ul>
<pre><code class="language-reason"><span class="hljs-keyword">type</span> result(&#x27;ok, &#x27;error) =
  | <span class="hljs-constructor">Ok</span>(&#x27;ok)
  | <span class="hljs-constructor">Error</span>(&#x27;error);
</code></pre>
<h2>Representing the request temporal status</h2>
<p>A request can be <strong>inactive</strong> (or &quot;not asked&quot;), <strong>loading</strong> or <strong>done</strong>. Let's create a type that fits that definition:</p>
<pre><code class="language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">RequestStatus</span> = {
  <span class="hljs-keyword">type</span> t(&#x27;a) =
    | <span class="hljs-constructor">NotAsked</span>
    | <span class="hljs-constructor">Loading</span>
    | <span class="hljs-constructor">Done</span>(&#x27;a);
};
</code></pre>
<h2>Combining the two</h2>
<pre><code class="language-reason"><span class="hljs-keyword">type</span> state = {
  user: <span class="hljs-module-identifier">RequestStatus</span>.t(<span class="hljs-module-identifier">Result</span>.t(<span class="hljs-module-identifier">User</span>.t, <span class="hljs-module-identifier">UserError</span>.t)),
};

<span class="hljs-keyword">type</span> action =
  | <span class="hljs-constructor">LoadUser</span>
  | <span class="hljs-constructor">ReceiveUser</span>(<span class="hljs-module-identifier">Result</span>.t(<span class="hljs-module-identifier">User</span>.t, <span class="hljs-module-identifier">UserError</span>.t));
</code></pre>
<p>In <strong>state</strong>, we need to have a representation at any point in time, so we need to wrap the <code>Result</code> in a <code>RequestStatus</code> type.</p>
<p>In <strong>action</strong>, <code>Load</code> and <code>Receive</code> already express temporality, <code>Receive</code> will only need to contain the <strong>request success status</strong>.</p>
<p>One big advantage of this approach is that we don't need to transform the success status in order to store it in the state, we only need to wrap it in a <code>RequestStatus</code>, meaning we only need one codepath in trivial situations.</p>
<p>In my component's reducer, I'll have something like the following:</p>
<pre><code class="language-reason"><span class="hljs-keyword">switch</span> (action) {
| <span class="hljs-constructor">LoadUser</span> =&gt;
  <span class="hljs-constructor">UpdateWithSideEffects</span>(
    {user: <span class="hljs-constructor">Loading</span>},
    (
      ({send}) =&gt;
        <span class="hljs-module-identifier">User</span>.query(payload =&gt; send(<span class="hljs-constructor">ReceiveUser</span>(payload)))
    ),
  )
| <span class="hljs-constructor">ReceiveUser</span>(payload) =&gt; <span class="hljs-constructor">Update</span>({user: <span class="hljs-constructor">Done</span>(payload)})
};
</code></pre>
<p>In my render function, I can then simply pattern match and have exhaustivity checks for free:</p>
<pre><code class="language-reason"><span class="hljs-keyword">switch</span> (state.user) {
| <span class="hljs-constructor">NotAsked</span> =&gt; &lt;<span class="hljs-module-identifier">Button</span> onPress=(() =&gt; send(<span class="hljs-constructor">LoadUser</span>)) title=<span class="hljs-string">&quot;Load&quot;</span> /&gt;
| <span class="hljs-constructor">Loading</span> =&gt; &lt;<span class="hljs-module-identifier">ActivityIndicator</span> /&gt;
| <span class="hljs-constructor">Done</span>(<span class="hljs-constructor">Error</span>(error)) =&gt; &lt;<span class="hljs-module-identifier">ErrorIndicator</span> error /&gt;
| <span class="hljs-constructor">Done</span>(<span class="hljs-constructor">Ok</span>(user)) =&gt; &lt;<span class="hljs-module-identifier">UserCard</span> user /&gt;
};
</code></pre>
</div><style data-emotion-rpcss="ujtx2m">.rpcss-ujtx2m{max-width:640px;width:100%;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:justify;-webkit-justify-content:space-between;-ms-flex-pack:justify;justify-content:space-between;margin:20px auto;padding:20px;background-color:#fff;border-radius:10px;box-shadow:0 15px 15px -5px rgba(0,0,0,0.2),0 0 0 1px rgba(0,0,0,0.1);}@media (prefers-color-scheme:dark){.rpcss-ujtx2m{background-color:#222;}}@media (max-width:540px){.rpcss-ujtx2m{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}</style><div class="rpcss-ujtx2m"><style data-emotion-rpcss="pbnpu2">.rpcss-pbnpu2{font-weight:800;font-size:18px;}</style><div class="rpcss-pbnpu2">Liked this article?</div><style data-emotion-rpcss="bb4ce3">.rpcss-bb4ce3{width:0px;height:10px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;}</style><div class="rpcss-bb4ce3"></div><style data-emotion-rpcss="1pkr03v">.rpcss-1pkr03v{background-color:#00aced;color:#fff;padding:10px 20px;-webkit-text-decoration:none;text-decoration:none;border-radius:5px;font-weight:800;}.rpcss-1pkr03v:active{opacity:0.5;}</style><a class="rpcss-1pkr03v" href="https://www.twitter.com/intent/tweet?text=Requests%20with%20ReasonML%20from%20%40bloodyowl%20https%3A%2F%2Fbloodyowl.io%2Fblog%2F2019-01-20-requests-with-reasonml" target="_blank">→ Share it on Twitter</a></div><style data-emotion-rpcss="sq4ju6">.rpcss-sq4ju6{padding:10px 0;}</style><div class="rpcss-sq4ju6"><div class="BeOpWidget"></div></div></div><style data-emotion-rpcss="7az74g">.rpcss-7az74g{background-color:#46515B;color:#fff;text-align:center;padding:20px;font-size:14px;}@media (prefers-color-scheme:dark){.rpcss-7az74g{background-color:#000;}}</style><div class="rpcss-7az74g">Copyright 2020 - Matthias Le Brun</div></div></div><script id="initialData" type="text/data">{"lists":{"RE_PRIVATE_NONE":true},"items":{"k":"blog","v":{"k":"2019-01-20-requests-with-reasonml","v":{"_0":{"TAG":0,"_0":{"slug":"2019-01-20-requests-with-reasonml","filename":"2019-01-20-requests-with-reasonml","title":"Requests with ReasonML","date":"Sun, 20 Jan 2019 00:00:00 GMT","draft":false,"meta":{"date":"2019-01-20T00:00:00.000Z","title":"Requests with ReasonML"},"body":"<blockquote>\n<p>This is how I choose to represent requests in my ReasonReact apps, there might be different ways that work well for you, but if this is something that you struggle with, that could be a good introduction to see how sum types can help you.</p>\n</blockquote>\n<p>Given there's no union type in JavaScript, we tend to use the following representation to store a request status in a component state</p>\n<pre><code class=\"language-javascript\"><span class=\"hljs-comment\">/* pseudo code */</span>\ntype state(data, error) = {\n  <span class=\"hljs-attr\">isLoading</span>: bool,\n  <span class=\"hljs-attr\">error</span>: nullable(error),\n  <span class=\"hljs-attr\">data</span>: nullable(data)\n};\n</code></pre>\n<p>and do something like this:</p>\n<pre><code class=\"language-javascript\">User.get(<span class=\"hljs-function\">(<span class=\"hljs-params\">error, data</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">if</span> (error) {\n    setState({ <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">false</span>, error });\n  } <span class=\"hljs-keyword\">else</span> {\n    setState({ <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">false</span>, data });\n  }\n});\n<span class=\"hljs-comment\">/* or */</span>\nUser.get().then(\n  <span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> setState({ <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">false</span>, data }),\n  <span class=\"hljs-function\"><span class=\"hljs-params\">error</span> =&gt;</span> setState({ <span class=\"hljs-attr\">isLoading</span>: <span class=\"hljs-literal\">false</span>, error })\n);\n</code></pre>\n<p>This pattern has two unfortunate consequences. The first one is that <strong>you can represent impossible states</strong> with it:</p>\n<table>\n<thead>\n<tr><th>isLoading</th><th>error</th><th>data</th><th>Is possible?</th></tr>\n</thead>\n<tbody>\n<tr><td><code>FALSE</code></td><td><code>NULL</code></td><td><code>NULL</code></td><td>✅</td></tr>\n<tr><td><code>TRUE</code></td><td><code>NULL</code></td><td><code>NULL</code></td><td>✅</td></tr>\n<tr><td><code>FALSE</code></td><td><code>ERROR</code></td><td><code>NULL</code></td><td>✅</td></tr>\n<tr><td><code>TRUE</code></td><td><code>ERROR</code></td><td><code>NULL</code></td><td>❌</td></tr>\n<tr><td><code>FALSE</code></td><td><code>NULL</code></td><td><code>DATA</code></td><td>✅</td></tr>\n<tr><td><code>TRUE</code></td><td><code>NULL</code></td><td><code>DATA</code></td><td>❌</td></tr>\n<tr><td><code>FALSE</code></td><td><code>ERROR</code></td><td><code>DATA</code></td><td>❌</td></tr>\n<tr><td><code>TRUE</code></td><td><code>ERROR</code></td><td><code>DATA</code></td><td>❌</td></tr>\n</tbody>\n</table>\n<p>The other one is that it makes you mix two different things:</p>\n<ul>\n<li>the request <strong>temporal</strong> status</li>\n<li>the request <strong>success</strong> status</li>\n</ul>\n<h2>Representing the request status</h2>\n<p>Typed functional language often have a <code>Result</code> or <code>Either</code> type. A result can be:</p>\n<ul>\n<li><code>Ok</code>, I have this data</li>\n<li><code>Error</code>, here what's faield</li>\n</ul>\n<pre><code class=\"language-reason\"><span class=\"hljs-keyword\">type</span> result(&#x27;ok, &#x27;error) =\n  | <span class=\"hljs-constructor\">Ok</span>(&#x27;ok)\n  | <span class=\"hljs-constructor\">Error</span>(&#x27;error);\n</code></pre>\n<h2>Representing the request temporal status</h2>\n<p>A request can be <strong>inactive</strong> (or &quot;not asked&quot;), <strong>loading</strong> or <strong>done</strong>. Let's create a type that fits that definition:</p>\n<pre><code class=\"language-reason\"><span class=\"hljs-keyword\">module</span> <span class=\"hljs-module-identifier\">RequestStatus</span> = {\n  <span class=\"hljs-keyword\">type</span> t(&#x27;a) =\n    | <span class=\"hljs-constructor\">NotAsked</span>\n    | <span class=\"hljs-constructor\">Loading</span>\n    | <span class=\"hljs-constructor\">Done</span>(&#x27;a);\n};\n</code></pre>\n<h2>Combining the two</h2>\n<pre><code class=\"language-reason\"><span class=\"hljs-keyword\">type</span> state = {\n  user: <span class=\"hljs-module-identifier\">RequestStatus</span>.t(<span class=\"hljs-module-identifier\">Result</span>.t(<span class=\"hljs-module-identifier\">User</span>.t, <span class=\"hljs-module-identifier\">UserError</span>.t)),\n};\n\n<span class=\"hljs-keyword\">type</span> action =\n  | <span class=\"hljs-constructor\">LoadUser</span>\n  | <span class=\"hljs-constructor\">ReceiveUser</span>(<span class=\"hljs-module-identifier\">Result</span>.t(<span class=\"hljs-module-identifier\">User</span>.t, <span class=\"hljs-module-identifier\">UserError</span>.t));\n</code></pre>\n<p>In <strong>state</strong>, we need to have a representation at any point in time, so we need to wrap the <code>Result</code> in a <code>RequestStatus</code> type.</p>\n<p>In <strong>action</strong>, <code>Load</code> and <code>Receive</code> already express temporality, <code>Receive</code> will only need to contain the <strong>request success status</strong>.</p>\n<p>One big advantage of this approach is that we don't need to transform the success status in order to store it in the state, we only need to wrap it in a <code>RequestStatus</code>, meaning we only need one codepath in trivial situations.</p>\n<p>In my component's reducer, I'll have something like the following:</p>\n<pre><code class=\"language-reason\"><span class=\"hljs-keyword\">switch</span> (action) {\n| <span class=\"hljs-constructor\">LoadUser</span> =&gt;\n  <span class=\"hljs-constructor\">UpdateWithSideEffects</span>(\n    {user: <span class=\"hljs-constructor\">Loading</span>},\n    (\n      ({send}) =&gt;\n        <span class=\"hljs-module-identifier\">User</span>.query(payload =&gt; send(<span class=\"hljs-constructor\">ReceiveUser</span>(payload)))\n    ),\n  )\n| <span class=\"hljs-constructor\">ReceiveUser</span>(payload) =&gt; <span class=\"hljs-constructor\">Update</span>({user: <span class=\"hljs-constructor\">Done</span>(payload)})\n};\n</code></pre>\n<p>In my render function, I can then simply pattern match and have exhaustivity checks for free:</p>\n<pre><code class=\"language-reason\"><span class=\"hljs-keyword\">switch</span> (state.user) {\n| <span class=\"hljs-constructor\">NotAsked</span> =&gt; &lt;<span class=\"hljs-module-identifier\">Button</span> onPress=(() =&gt; send(<span class=\"hljs-constructor\">LoadUser</span>)) title=<span class=\"hljs-string\">&quot;Load&quot;</span> /&gt;\n| <span class=\"hljs-constructor\">Loading</span> =&gt; &lt;<span class=\"hljs-module-identifier\">ActivityIndicator</span> /&gt;\n| <span class=\"hljs-constructor\">Done</span>(<span class=\"hljs-constructor\">Error</span>(error)) =&gt; &lt;<span class=\"hljs-module-identifier\">ErrorIndicator</span> error /&gt;\n| <span class=\"hljs-constructor\">Done</span>(<span class=\"hljs-constructor\">Ok</span>(user)) =&gt; &lt;<span class=\"hljs-module-identifier\">UserCard</span> user /&gt;\n};\n</code></pre>\n"}}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"h":1,"l":{"RE_PRIVATE_NONE":true},"r":{"RE_PRIVATE_NONE":true}},"listsRequests":{"data":{"RE_PRIVATE_NONE":true}},"itemsRequests":{"data":{"RE_PRIVATE_NONE":true}}}</script><script defer="defer" src="/public/main.7c50588d2bc634256699.js"></script></html>