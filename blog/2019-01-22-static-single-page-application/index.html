<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="google-site-verification"
      content="w75-P-0ywXWkyZvYPbkSM3VSM2hny25UrfeiWJt3B1k"
    />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, shrink-to-fit=no"
    />
    <meta
      name="description"
      content="Front-end developer and designer. ReasonML, ReasonReact, ReactJS."
    />
    <meta name="twitter:card" content="summary_large_image">
    <meta property="og:type" content="website">
    <meta property="og:image" content="https://bloodyowl.io/public/assets/images/share.jpg">
    <meta name="twitter:image" content="https://bloodyowl.io/public/assets/images/share.jpg">
    <meta name="twitter:site" content="@bloodyowl">
    <meta property="og:image:width" content="1500">
    <meta property="og:image:height" content="777">
    <link rel="shortcut icon" href="/public/assets/images/favicon.png" />
    <title>Static single page application | @bloodyowl</title><meta property="og:title" content="Static single page application | @bloodyowl" />
  </head>
  <body>
    <div id="root"><style data-emotion-css="189z874 gu50q 1sk4geg 12as1jd inii90 kk4a7b 16cj527 1moa3kc 18av5pk 1jtjujg j1f6xt a7hgs6 1h80fpx saz23d 2o7l8j bgur92 gghbgz 18z74vx 1qdfdal">pre{padding:10px 20px;background-color:#F4F7F8;overflow-x:auto;-webkit-overflow-scrolling:touch;font-size:14px;}code{font-family:PragmataPro,SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;line-height:1;}.hljs-keyword{color:#DA6BB5;}.hljs-constructor{color:#DD792B;}.hljs-identifier{color:#1E9EA7;}.hljs-module-identifier{color:#C84682;}.hljs-string{color:#3BA1C8;}.hljs-comment{color:#aaa;}.hljs-operator{color:#DA6BB5;}.hljs-attribute{color:#4CB877;}table{width:100%;text-align:center;}table thead th{background-color:#E4EBEE;padding:10px 0;}blockquote{opacity:0.6;border-left:4px solid #46515B;margin:0;padding:0 20px;}@font-face{font-family:Madera;src:url("/public/assets/webfonts/madera.ttf");font-style:normal;font-weight:400;font-display:swap;}@font-face{font-family:Madera;src:url("/public/assets/webfonts/madera-bold.ttf");font-style:normal;font-weight:700;font-display:swap;}body{padding:0;margin:0;background-color:#fff;font-family:Madera,"Helvetica Neue",Helvetica,Arial,sans-serif;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;min-height:100vh;overflow-x:hidden;}#root{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}html{color:#46515B;font-size:1em;line-height:1.4;-webkit-font-smoothing:antialiased;-webkit-text-size-adjust:100%;}*,*:before,*:after{box-sizing:border-box;}</style><style data-emotion-css="1lm8k0f">.css-1lm8k0f{min-height:100vh;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;}</style><div class="css-1lm8k0f" data-reactroot=""><style data-emotion-css="14wlb7f">.css-14wlb7f{background-color:#E4EBEE;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;}@media (max-width:620px){.css-14wlb7f{-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}}</style><div class="css-14wlb7f"><style data-emotion-css="48zunz">.css-48zunz{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:stretch;-webkit-box-align:stretch;-ms-flex-align:stretch;align-items:stretch;-webkit-flex-wrap:wrap;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;color:#46515B;-webkit-text-decoration:none;text-decoration:none;}</style><a href="/" class="css-48zunz"><style data-emotion-css="19jaiin">.css-19jaiin{margin-right:10px;margin-left:20px;-webkit-align-self:center;-ms-flex-item-align:center;align-self:center;}</style><img class="css-19jaiin" alt="" height="32" src="/public/assets/images/owl.svg" width="32"/><style data-emotion-css="16ucz1n">.css-16ucz1n{padding:20px 20px 23px 0;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}</style><div aria-level="1" class="css-16ucz1n" role="heading"><style data-emotion-css="x6blf3">.css-x6blf3{font-weight:700;margin-right:10px;white-space:nowrap;}</style><div class="css-x6blf3">Matthias Le Brun</div><div>@bloodyowl</div></div></a><style data-emotion-css="7nltf6">.css-7nltf6{display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;-webkit-align-items:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;}@media (max-width:620px){.css-7nltf6{-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;background-color:#D4E1E6;}}</style><div class="css-7nltf6"><style data-emotion-css="143gsgu">.css-143gsgu{padding:20px 20px 23px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-text-decoration:none;text-decoration:none;color:#46515B;text-align:center;font-weight:700;}@media (max-width:620px){.css-143gsgu{-webkit-flex-basis:33.333%;-ms-flex-preferred-size:33.333%;flex-basis:33.333%;padding:10px 20px 13px;}}</style><a href="/blog/" class="css-143gsgu">Blog</a><style data-emotion-css="1o16z30">.css-1o16z30{padding:20px 20px 23px;-webkit-flex-shrink:0;-ms-flex-negative:0;flex-shrink:0;-webkit-text-decoration:none;text-decoration:none;color:#46515B;text-align:center;}@media (max-width:620px){.css-1o16z30{-webkit-flex-basis:33.333%;-ms-flex-preferred-size:33.333%;flex-basis:33.333%;padding:10px 20px 13px;}}</style><a href="https://twitter.com/bloodyowl" class="css-1o16z30">Twitter</a><a href="https://github.com/bloodyowl" class="css-1o16z30">GitHub</a></div></div><style data-emotion-css="12z655i">.css-12z655i{max-width:600px;padding:0 10px;margin:20px auto;width:100%;-webkit-box-flex:1;-webkit-flex-grow:1;-ms-flex-positive:1;flex-grow:1;}</style><div class="css-12z655i"><style data-emotion-css="1lz15hj">.css-1lz15hj{margin:0;margin-bottom:10px;}</style><h1 class="css-1lz15hj">Static single page application</h1><style data-emotion-css="v7jbmu">.css-v7jbmu{font-size:14px;opacity:0.5;}</style><div class="css-v7jbmu">2019/01/22</div><style data-emotion-css="b2zag1">.css-b2zag1{margin-top:40px;font-size:18px;}.css-b2zag1 a{color:#135EFF;}.css-b2zag1 a:hover{color:#13A3FF;}</style><div class="css-b2zag1"><p>As you can see from the URL, this little website is hosted on GitHub pages, meaning it can only be static.</p>
<p>The approach I chose here was to build it like a single page application that I'd render at build time.</p>
<p>This approach gives the best of both worlds :</p>
<ul>
<li>an familiar and powerful way to build UIs</li>
<li>a fast initial load</li>
<li>a fast navigation after the first load: any transition that occur after will only query the smallest amount data it possibly can in order to render the next route</li>
</ul>
<h2>Getting the data for the blog</h2>
<p>I have a blog direction with markdown files. In order to get them, I made a few bindings to glob, remarkable and front-matter so that I can transform posts into two kinds of records:</p>
<pre><code class="language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">PostShallow</span> = {
  <span class="hljs-keyword">type</span> t = {
    title: string,
    date: string,
    slug: string,
  };
};

<span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Post</span> = {
  <span class="hljs-keyword">type</span> t = {
    title: string,
    date: string,
    body: string,
  };
};
</code></pre>
<p><code>postShallow</code> will be used in listings, and <code>post</code> for the detail page.</p>
<h2>The routing</h2>
<p>Given I use ReasonReact, I use the builtin Router solution. At first it was in my <code>App</code> component state.</p>
<pre><code class="language-reason"><span class="hljs-keyword">let</span> component = <span class="hljs-module-identifier">React</span>.reducerComponent(<span class="hljs-string">"App"</span>);

<span class="hljs-keyword">let</span> make = (_) =&gt; {
  <span class="hljs-operator">...</span>component,
  initialState: () =&gt; <span class="hljs-module-identifier">React</span>.<span class="hljs-module-identifier">Router</span>.dangerouslyGetInitialUrl(),
  reducer: (action, _state) =&gt;
    <span class="hljs-keyword">switch</span> action {
    | <span class="hljs-constructor">SetRoute</span>(url) =&gt; <span class="hljs-constructor">Update</span>(url)
    },
  <span class="hljs-comment">/* ... */</span>
}
</code></pre>
<p>In order to make it statically renderable, I moved it from <code>state</code> to props. I now have a <code>Main</code> module with a recursive render function that calls itself whenever there's a URL change.</p>
<pre><code class="language-reason"><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> render = (~url=<span class="hljs-module-identifier">React</span>.<span class="hljs-module-identifier">Router</span>.dangerouslyGetInitialUrl(), ()) =&gt; {
  <span class="hljs-comment">/* render logic here */</span>
  <span class="hljs-keyword">let</span> watcherId = ref(<span class="hljs-constructor">None</span>);
  watcherId <span class="hljs-operator">:=</span>
    <span class="hljs-constructor">Some</span>(
      <span class="hljs-module-identifier">React</span>.<span class="hljs-module-identifier">Router</span>.watchUrl(url =&gt; {
        (watcherId<span class="hljs-operator">^</span>)
        <span class="hljs-operator">-&gt;</span><span class="hljs-module-identifier">Option</span>.map(watcherId =&gt; <span class="hljs-module-identifier">React</span>.<span class="hljs-module-identifier">Router</span>.unwatchUrl(watcherId))
        <span class="hljs-operator">-&gt;</span>ignore;
        render(~url, ());
      }),
    );
}
</code></pre>
<p>This render function will only be used on the client. At build time we'll call App directly. An important thing to remember here is that your CSS reset needs to be in App, otherwise it'll only be called once the client boots.</p>
<h2>The data</h2>
<p>Initially I planned to put data in route component states themselves, but this would've required extra steps in serialisation I didn't want to take for such a simple project.</p>
<p>I simply moved the data up the <code>App</code> component state, and passed two things to the routes:</p>
<ul>
<li>the data they need</li>
<li>a callback to set this data when received</li>
</ul>
<p>The app state actually looks quite simple:</p>
<pre><code class="language-reason"><span class="hljs-keyword">type</span> state = {
  posts: <span class="hljs-module-identifier">Map</span>.<span class="hljs-module-identifier">String</span>.t(<span class="hljs-module-identifier">RequestStatus</span>.t(<span class="hljs-module-identifier">Result</span>.t(<span class="hljs-module-identifier">Post</span>.t, <span class="hljs-module-identifier">Errors</span>.t))),
  postList: <span class="hljs-module-identifier">RequestStatus</span>.t(<span class="hljs-module-identifier">Result</span>.t(array(<span class="hljs-module-identifier">PostShallow</span>.t), <span class="hljs-module-identifier">Errors</span>.t)),
};
</code></pre>
<p>This way, only App is changed when the store shape changes. I could've passed the initial data so that routes can hydrate their initial state, but that would defeat the purpose for an efficient loading experience: it would've refreshed the data every time the route mounts instead of keeping it.</p>
<h2>The styles</h2>
<p>I use <a href="https://github.com/SentiaAnalytics/bs-css">bs-css</a>, which recently switched to emotion. It simply required to write a little binding to emotion-server in order to render styles on the server.</p>
<pre><code class="language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Emotion</span> = {
  <span class="hljs-attribute">[@bs.module "emotion-server"]</span>
  <span class="hljs-keyword">external</span> renderStylesToString: string =&gt; string = <span class="hljs-string">"renderStylesToString"</span>;
};
</code></pre>
<h2>Hydration</h2>
<p>For the hydration, I just check if my root element is empty and hydrate instead of render if it's not.</p>
<pre><code class="language-reason"><span class="hljs-keyword">let</span> markup =
  <span class="hljs-module-identifier">DomRe</span>.(
    <span class="hljs-module-identifier">Document</span>.getElementById(<span class="hljs-string">"root"</span>, document)
    <span class="hljs-operator">-&gt;</span><span class="hljs-module-identifier">Option</span>.map(<span class="hljs-module-identifier">Element</span>.innerHTML)
    <span class="hljs-operator">-&gt;</span><span class="hljs-module-identifier">Option</span>.flatMap(item =&gt; item <span class="hljs-operator">==</span> <span class="hljs-string">""</span> ? <span class="hljs-constructor">None</span> : <span class="hljs-constructor">Some</span>(item))
  );
  
<span class="hljs-keyword">switch</span> (markup) {
| <span class="hljs-constructor">Some</span>(_) =&gt;
  <span class="hljs-module-identifier">ReactDOMRe</span>.hydrateToElementWithId(&lt;<span class="hljs-module-identifier">App</span> url ?initialData /&gt;, <span class="hljs-string">"root"</span>)
| <span class="hljs-constructor">None</span> =&gt;
  <span class="hljs-module-identifier">ReactDOMRe</span>.renderToElementWithId(&lt;<span class="hljs-module-identifier">App</span> url ?initialData /&gt;, <span class="hljs-string">"root"</span>)
};
</code></pre>
<h2>Prerender all the pages</h2>
<p>First, I render a dummy HTML file using html-webpack-plugin, it'll be used as a template for all the pages. The plugin will just add the right app JS.</p>
<p>I just list all pages with their URLs and the App state they need to render, and replace elements from the template with the rendered HTML, title and initial data and write files in the build directory.</p>
<pre><code class="language-reason"><span class="hljs-module-identifier">Node</span>.<span class="hljs-module-identifier">Fs</span>.writeFileAsUtf8Sync(
  <span class="hljs-string">"./build/"</span> <span class="hljs-operator">++</span> <span class="hljs-module-identifier">String</span>.concat(<span class="hljs-string">"/"</span>, path) <span class="hljs-operator">++</span> <span class="hljs-string">"/index.html"</span>,
  index
  <span class="hljs-operator">-&gt;</span><span class="hljs-module-identifier">Js</span>.<span class="hljs-module-identifier">String</span>.replace(
      <span class="hljs-string">{|&lt;div id="root"&gt;&lt;/div&gt;|}</span>,
      <span class="hljs-string">{j|&lt;div id="root"&gt;$prerendered&lt;/div&gt;&lt;script id="data"&gt;window.initialData = $data&lt;/script&gt;|j}</span>,
      _,
    )
  <span class="hljs-operator">-&gt;</span><span class="hljs-module-identifier">Js</span>.<span class="hljs-module-identifier">String</span>.replace(
      <span class="hljs-string">{|&lt;title&gt;TITLE&lt;/title&gt;|}</span>,
      <span class="hljs-string">{j|&lt;title&gt;$title | @bloodyowl&lt;/title&gt;&lt;meta property="og:title" content="$title | @bloodyowl" /&gt;|j}</span>,
      _,
    ),
);
</code></pre>
</div><style data-emotion-css="sq4ju6">.css-sq4ju6{padding:10px 0;}</style><div class="css-sq4ju6"><div class="BeOpWidget"></div></div></div><style data-emotion-css="18aspvx">.css-18aspvx{background-color:#46515B;color:#fff;text-align:center;padding:20px;font-size:14px;}</style><div class="css-18aspvx">Copyright 2020 - Matthias Le Brun</div></div></div><script id="data">window.initialData = {"posts":{"key":"2019-01-22-static-single-page-application","value":[[{"title":"Static single page application","date":"2019-01-22T00:00:00.000Z","body":"\u003cp>As you can see from the URL, this little website is hosted on GitHub pages, meaning it can only be static.\u003c/p>\n\u003cp>The approach I chose here was to build it like a single page application that I'd render at build time.\u003c/p>\n\u003cp>This approach gives the best of both worlds :\u003c/p>\n\u003cul>\n\u003cli>an familiar and powerful way to build UIs\u003c/li>\n\u003cli>a fast initial load\u003c/li>\n\u003cli>a fast navigation after the first load: any transition that occur after will only query the smallest amount data it possibly can in order to render the next route\u003c/li>\n\u003c/ul>\n\u003ch2>Getting the data for the blog\u003c/h2>\n\u003cp>I have a blog direction with markdown files. In order to get them, I made a few bindings to glob, remarkable and front-matter so that I can transform posts into two kinds of records:\u003c/p>\n\u003cpre>\u003ccode class=\"language-reason\">\u003cspan class=\"hljs-keyword\">module\u003c/span> \u003cspan class=\"hljs-module-identifier\">PostShallow\u003c/span> = {\n  \u003cspan class=\"hljs-keyword\">type\u003c/span> t = {\n    title: string,\n    date: string,\n    slug: string,\n  };\n};\n\n\u003cspan class=\"hljs-keyword\">module\u003c/span> \u003cspan class=\"hljs-module-identifier\">Post\u003c/span> = {\n  \u003cspan class=\"hljs-keyword\">type\u003c/span> t = {\n    title: string,\n    date: string,\n    body: string,\n  };\n};\n\u003c/code>\u003c/pre>\n\u003cp>\u003ccode>postShallow\u003c/code> will be used in listings, and \u003ccode>post\u003c/code> for the detail page.\u003c/p>\n\u003ch2>The routing\u003c/h2>\n\u003cp>Given I use ReasonReact, I use the builtin Router solution. At first it was in my \u003ccode>App\u003c/code> component state.\u003c/p>\n\u003cpre>\u003ccode class=\"language-reason\">\u003cspan class=\"hljs-keyword\">let\u003c/span> component = \u003cspan class=\"hljs-module-identifier\">React\u003c/span>.reducerComponent(\u003cspan class=\"hljs-string\">\"App\"\u003c/span>);\n\n\u003cspan class=\"hljs-keyword\">let\u003c/span> make = (_) =&gt; {\n  \u003cspan class=\"hljs-operator\">...\u003c/span>component,\n  initialState: () =&gt; \u003cspan class=\"hljs-module-identifier\">React\u003c/span>.\u003cspan class=\"hljs-module-identifier\">Router\u003c/span>.dangerouslyGetInitialUrl(),\n  reducer: (action, _state) =&gt;\n    \u003cspan class=\"hljs-keyword\">switch\u003c/span> action {\n    | \u003cspan class=\"hljs-constructor\">SetRoute\u003c/span>(url) =&gt; \u003cspan class=\"hljs-constructor\">Update\u003c/span>(url)\n    },\n  \u003cspan class=\"hljs-comment\">/* ... */\u003c/span>\n}\n\u003c/code>\u003c/pre>\n\u003cp>In order to make it statically renderable, I moved it from \u003ccode>state\u003c/code> to props. I now have a \u003ccode>Main\u003c/code> module with a recursive render function that calls itself whenever there's a URL change.\u003c/p>\n\u003cpre>\u003ccode class=\"language-reason\">\u003cspan class=\"hljs-keyword\">let\u003c/span> \u003cspan class=\"hljs-keyword\">rec\u003c/span> render = (~url=\u003cspan class=\"hljs-module-identifier\">React\u003c/span>.\u003cspan class=\"hljs-module-identifier\">Router\u003c/span>.dangerouslyGetInitialUrl(), ()) =&gt; {\n  \u003cspan class=\"hljs-comment\">/* render logic here */\u003c/span>\n  \u003cspan class=\"hljs-keyword\">let\u003c/span> watcherId = ref(\u003cspan class=\"hljs-constructor\">None\u003c/span>);\n  watcherId \u003cspan class=\"hljs-operator\">:=\u003c/span>\n    \u003cspan class=\"hljs-constructor\">Some\u003c/span>(\n      \u003cspan class=\"hljs-module-identifier\">React\u003c/span>.\u003cspan class=\"hljs-module-identifier\">Router\u003c/span>.watchUrl(url =&gt; {\n        (watcherId\u003cspan class=\"hljs-operator\">^\u003c/span>)\n        \u003cspan class=\"hljs-operator\">-&gt;\u003c/span>\u003cspan class=\"hljs-module-identifier\">Option\u003c/span>.map(watcherId =&gt; \u003cspan class=\"hljs-module-identifier\">React\u003c/span>.\u003cspan class=\"hljs-module-identifier\">Router\u003c/span>.unwatchUrl(watcherId))\n        \u003cspan class=\"hljs-operator\">-&gt;\u003c/span>ignore;\n        render(~url, ());\n      }),\n    );\n}\n\u003c/code>\u003c/pre>\n\u003cp>This render function will only be used on the client. At build time we'll call App directly. An important thing to remember here is that your CSS reset needs to be in App, otherwise it'll only be called once the client boots.\u003c/p>\n\u003ch2>The data\u003c/h2>\n\u003cp>Initially I planned to put data in route component states themselves, but this would've required extra steps in serialisation I didn't want to take for such a simple project.\u003c/p>\n\u003cp>I simply moved the data up the \u003ccode>App\u003c/code> component state, and passed two things to the routes:\u003c/p>\n\u003cul>\n\u003cli>the data they need\u003c/li>\n\u003cli>a callback to set this data when received\u003c/li>\n\u003c/ul>\n\u003cp>The app state actually looks quite simple:\u003c/p>\n\u003cpre>\u003ccode class=\"language-reason\">\u003cspan class=\"hljs-keyword\">type\u003c/span> state = {\n  posts: \u003cspan class=\"hljs-module-identifier\">Map\u003c/span>.\u003cspan class=\"hljs-module-identifier\">String\u003c/span>.t(\u003cspan class=\"hljs-module-identifier\">RequestStatus\u003c/span>.t(\u003cspan class=\"hljs-module-identifier\">Result\u003c/span>.t(\u003cspan class=\"hljs-module-identifier\">Post\u003c/span>.t, \u003cspan class=\"hljs-module-identifier\">Errors\u003c/span>.t))),\n  postList: \u003cspan class=\"hljs-module-identifier\">RequestStatus\u003c/span>.t(\u003cspan class=\"hljs-module-identifier\">Result\u003c/span>.t(array(\u003cspan class=\"hljs-module-identifier\">PostShallow\u003c/span>.t), \u003cspan class=\"hljs-module-identifier\">Errors\u003c/span>.t)),\n};\n\u003c/code>\u003c/pre>\n\u003cp>This way, only App is changed when the store shape changes. I could've passed the initial data so that routes can hydrate their initial state, but that would defeat the purpose for an efficient loading experience: it would've refreshed the data every time the route mounts instead of keeping it.\u003c/p>\n\u003ch2>The styles\u003c/h2>\n\u003cp>I use \u003ca href=\"https://github.com/SentiaAnalytics/bs-css\">bs-css\u003c/a>, which recently switched to emotion. It simply required to write a little binding to emotion-server in order to render styles on the server.\u003c/p>\n\u003cpre>\u003ccode class=\"language-reason\">\u003cspan class=\"hljs-keyword\">module\u003c/span> \u003cspan class=\"hljs-module-identifier\">Emotion\u003c/span> = {\n  \u003cspan class=\"hljs-attribute\">[@bs.module \"emotion-server\"]\u003c/span>\n  \u003cspan class=\"hljs-keyword\">external\u003c/span> renderStylesToString: string =&gt; string = \u003cspan class=\"hljs-string\">\"renderStylesToString\"\u003c/span>;\n};\n\u003c/code>\u003c/pre>\n\u003ch2>Hydration\u003c/h2>\n\u003cp>For the hydration, I just check if my root element is empty and hydrate instead of render if it's not.\u003c/p>\n\u003cpre>\u003ccode class=\"language-reason\">\u003cspan class=\"hljs-keyword\">let\u003c/span> markup =\n  \u003cspan class=\"hljs-module-identifier\">DomRe\u003c/span>.(\n    \u003cspan class=\"hljs-module-identifier\">Document\u003c/span>.getElementById(\u003cspan class=\"hljs-string\">\"root\"\u003c/span>, document)\n    \u003cspan class=\"hljs-operator\">-&gt;\u003c/span>\u003cspan class=\"hljs-module-identifier\">Option\u003c/span>.map(\u003cspan class=\"hljs-module-identifier\">Element\u003c/span>.innerHTML)\n    \u003cspan class=\"hljs-operator\">-&gt;\u003c/span>\u003cspan class=\"hljs-module-identifier\">Option\u003c/span>.flatMap(item =&gt; item \u003cspan class=\"hljs-operator\">==\u003c/span> \u003cspan class=\"hljs-string\">\"\"\u003c/span> ? \u003cspan class=\"hljs-constructor\">None\u003c/span> : \u003cspan class=\"hljs-constructor\">Some\u003c/span>(item))\n  );\n  \n\u003cspan class=\"hljs-keyword\">switch\u003c/span> (markup) {\n| \u003cspan class=\"hljs-constructor\">Some\u003c/span>(_) =&gt;\n  \u003cspan class=\"hljs-module-identifier\">ReactDOMRe\u003c/span>.hydrateToElementWithId(&lt;\u003cspan class=\"hljs-module-identifier\">App\u003c/span> url ?initialData /&gt;, \u003cspan class=\"hljs-string\">\"root\"\u003c/span>)\n| \u003cspan class=\"hljs-constructor\">None\u003c/span> =&gt;\n  \u003cspan class=\"hljs-module-identifier\">ReactDOMRe\u003c/span>.renderToElementWithId(&lt;\u003cspan class=\"hljs-module-identifier\">App\u003c/span> url ?initialData /&gt;, \u003cspan class=\"hljs-string\">\"root\"\u003c/span>)\n};\n\u003c/code>\u003c/pre>\n\u003ch2>Prerender all the pages\u003c/h2>\n\u003cp>First, I render a dummy HTML file using html-webpack-plugin, it'll be used as a template for all the pages. The plugin will just add the right app JS.\u003c/p>\n\u003cp>I just list all pages with their URLs and the App state they need to render, and replace elements from the template with the rendered HTML, title and initial data and write files in the build directory.\u003c/p>\n\u003cpre>\u003ccode class=\"language-reason\">\u003cspan class=\"hljs-module-identifier\">Node\u003c/span>.\u003cspan class=\"hljs-module-identifier\">Fs\u003c/span>.writeFileAsUtf8Sync(\n  \u003cspan class=\"hljs-string\">\"./build/\"\u003c/span> \u003cspan class=\"hljs-operator\">++\u003c/span> \u003cspan class=\"hljs-module-identifier\">String\u003c/span>.concat(\u003cspan class=\"hljs-string\">\"/\"\u003c/span>, path) \u003cspan class=\"hljs-operator\">++\u003c/span> \u003cspan class=\"hljs-string\">\"/index.html\"\u003c/span>,\n  index\n  \u003cspan class=\"hljs-operator\">-&gt;\u003c/span>\u003cspan class=\"hljs-module-identifier\">Js\u003c/span>.\u003cspan class=\"hljs-module-identifier\">String\u003c/span>.replace(\n      \u003cspan class=\"hljs-string\">{|&lt;div id=\"root\"&gt;&lt;/div&gt;|}\u003c/span>,\n      \u003cspan class=\"hljs-string\">{j|&lt;div id=\"root\"&gt;$prerendered&lt;/div&gt;&lt;script id=\"data\"&gt;window.initialData = $data&lt;/script&gt;|j}\u003c/span>,\n      _,\n    )\n  \u003cspan class=\"hljs-operator\">-&gt;\u003c/span>\u003cspan class=\"hljs-module-identifier\">Js\u003c/span>.\u003cspan class=\"hljs-module-identifier\">String\u003c/span>.replace(\n      \u003cspan class=\"hljs-string\">{|&lt;title&gt;TITLE&lt;/title&gt;|}\u003c/span>,\n      \u003cspan class=\"hljs-string\">{j|&lt;title&gt;$title | @bloodyowl&lt;/title&gt;&lt;meta property=\"og:title\" content=\"$title | @bloodyowl\" /&gt;|j}\u003c/span>,\n      _,\n    ),\n);\n\u003c/code>\u003c/pre>\n"}]],"height":1},"postList":0}</script>
    <script>
      window.beOpAsyncInit = function() {
        BeOpSDK.init({
          account: "556e1d2772a6b60100844051"
        });
        BeOpSDK.watch();
      };
    </script>
    <script defer src="https://widget.beop.io/sdk.js"></script>
  <script type="text/javascript" src="/app.584345de999128bd8c1b.js" defer></script></body>
</html>
