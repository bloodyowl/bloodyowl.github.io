{"slug":"2019-02-09-how-reason-react-router-represents-a-url","filename":"2019-02-09-how-reason-react-router-represents-a-url","title":"How ReasonReact.Router represents a URL","date":"Sat, 09 Feb 2019 00:00:00 GMT","draft":false,"meta":{"date":"2019-02-09T00:00:00.000Z","title":"How ReasonReact.Router represents a URL"},"body":"<p>ReasonReact embeds a small router out of the box.</p>\n<p>Its API surface is smaller than most solutions you can find out there, but it leverage some languages data-structures in an interesting way, particularly in how it represents URL paths.</p>\n<p>Here's how it looks:</p>\n<pre><code class=\"language-reason\"><span class=\"hljs-keyword\">type</span> url = {\n  path: list(string),\n  search: string,\n  hash: string,\n};\n</code></pre>\n<p>The most interesting part here is the way path is represented: a list, with each item in it being a segment (separated by <code>/</code>).</p>\n<p>Lists in OCaml/ReasonML are <strong>linked lists</strong>, which means they are composed roughly that way:</p>\n<pre><code class=\"language-reason\"><span class=\"hljs-keyword\">type</span> list(&#x27;a) =\n  | <span class=\"hljs-constructor\">Empty</span>\n  | <span class=\"hljs-constructor\">One</span>(&#x27;a, list(&#x27;a)); <span class=\"hljs-comment\">/* look! it&#x27;s a recursive type */</span>\n</code></pre>\n<p>The rest of the list (or <em>tail</em>) is another list! And you can loop through it using recursion and pattern matching:</p>\n<pre><code class=\"language-reason\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">rec</span> map = (list, f) =&gt;\n  <span class=\"hljs-keyword\">switch</span> (list) {\n  | <span class=\"hljs-constructor\">Empty</span> =&gt; <span class=\"hljs-constructor\">Empty</span> <span class=\"hljs-comment\">/* we&#x27;re at the end, return empty*/</span>\n  | <span class=\"hljs-constructor\">One</span>(x, rest) =&gt;\n    <span class=\"hljs-constructor\">One</span>(f(x), map(rest, f)) <span class=\"hljs-comment\">/* tranform x, and map the rest*/</span>\n  };\n</code></pre>\n<p>In ReasonML, there's syntactic sugar for that: the equivalent of <code>Empty</code> is <code>[]</code>, and of <code>One(x, rest)</code> is <code>[x, ...rest]</code> (and <code>x :: rest</code> in OCaml).</p>\n<p>So <code>map</code> would in reality look like:</p>\n<pre><code class=\"language-reason\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">rec</span> map = (list, f) =&gt;\n  <span class=\"hljs-keyword\">switch</span> (list) {\n  | <span class=\"hljs-literal\">[</span><span class=\"hljs-literal\">]</span> =&gt; <span class=\"hljs-literal\">[</span><span class=\"hljs-literal\">]</span>\n  | <span class=\"hljs-literal\">[</span>x, <span class=\"hljs-operator\">...</span>rest<span class=\"hljs-literal\">]</span> =&gt; <span class=\"hljs-literal\">[</span>f(x), <span class=\"hljs-operator\">...</span>map(rest, f)<span class=\"hljs-literal\">]</span>\n  };\n</code></pre>\n<p>In the context of a router, lists are pretty interesting too, as URL paths generally represent <strong>depth</strong> (e.g. <code>/users/id</code> is one level deeper than <code>/users</code>):</p>\n<pre><code class=\"language-reason\"><span class=\"hljs-keyword\">switch</span> (url.path) {\n| <span class=\"hljs-literal\">[</span><span class=\"hljs-literal\">]</span> =&gt; &lt;<span class=\"hljs-module-identifier\">Home</span> /&gt;\n| <span class=\"hljs-literal\">[</span><span class=\"hljs-string\">&quot;me&quot;</span>, <span class=\"hljs-operator\">...</span>subPath<span class=\"hljs-literal\">]</span> =&gt; &lt;<span class=\"hljs-module-identifier\">Settings</span> id=me.id subPath /&gt;\n| <span class=\"hljs-literal\">[</span><span class=\"hljs-string\">&quot;users&quot;</span>, id, <span class=\"hljs-string\">&quot;settings&quot;</span>, <span class=\"hljs-operator\">...</span>subPath<span class=\"hljs-literal\">]</span> =&gt; &lt;<span class=\"hljs-module-identifier\">Settings</span> id subPath /&gt;\n| _ =&gt; &lt;<span class=\"hljs-module-identifier\">NotFound</span> /&gt;\n};\n</code></pre>\n<p>You can handle subroutes in a descendant by passing down the tail of the path! And nice side effect: because you just take the list after an item, <strong>you don't allocate anything</strong>: you just pass tail the list itself.</p>\n"}