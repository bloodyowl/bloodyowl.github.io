{"slug":"2021-01-09-write-dumb-code","filename":"2021-01-09-write-dumb-code","title":"Write dumb code","date":"Sat, 09 Jan 2021 00:00:00 GMT","draft":false,"meta":{"title":"Write dumb code","date":"2021-01-09T00:00:00.000Z"},"body":"<p>Most of us, in the early years of our carreers focus on making code <strong>that we can be proud of</strong>. Clean code. Elegant code. Smart code.</p>\n<p>I used to spend hours trying to make my code do smart stuff, avoiding repetition at all cost with factorisation, writing abstractions all over the place, making sure that I wrote the shortest snippet possible for a given task.</p>\n<p>I don't give a f**k about that anymore. At all.</p>\n<p>I came to a small mantra:</p>\n<div style=\"font-size: 32px; text-align: center;\">\n  <strong>Make smart plans.</strong><br>\n  <strong>Write dumb code.</strong>\n</div>\n<h2>why → how → what</h2>\n<p>I really like Simon Sinek's <a href=\"https://www.youtube.com/watch?v=u4ZoJKF_VuA\">«Start with why»</a> TED talk (you've probably already seen it), and while it speaks about companies, I think that the general idea is applicable to a lot of fields.</p>\n<p>To paraphrase a little: <strong>start from the vision, then figure out how to make it happen, then do it</strong>.</p>\n<p><img src=\"/public/assets/images/GoldenCircle.png\" alt=\"Why, how and what\" /></p>\n<p>Of course Sinek talks about a general principle, but in our case it also works in the small.</p>\n<h3>why</h3>\n<p>Knowing the <strong>why</strong> is what makes us understand from the start what <strong>value</strong> we're expected to bring. The <strong>why</strong> is our guideline, what we aim for. When knowing the <strong>why</strong>, even if we get stuck on the technical part, it gives us the opportunity to find alternative ways to provide a similar value.</p>\n<h3>how</h3>\n<p>Once we know <strong>why</strong> we'll do something, we can focus on the <strong>how</strong>. <strong>How</strong> are we going to make that happen? <strong>How</strong> will it work? <strong>How</strong> will our feature, our project, our fix, fit in the project? <strong>How</strong> does solution one compares to solution two?</p>\n<h3>what</h3>\n<p>When you've planned <strong>how</strong>, the <strong>what</strong> is the least interesting part. It is a translation job. We write in one language what we've expressed in another.</p>\n<p>Doing things in that order is beneficial in many ways to the organisation and the people in it:</p>\n<ul>\n<li>people get to know the value that they'll bring from the start</li>\n<li>with the goal in mind, they'll be able to have better ideas</li>\n<li>it eliminates &quot;bad&quot; ideas early in the process</li>\n</ul>\n<h2>Our job isn't about code</h2>\n<p>What I consider to be a good developer isn't someone who'll be able to write the most efficient single-line snippet, but someone who is good at getting from <strong>why</strong> to <strong>how</strong>, and simply happens to make the <strong>what</strong>.</p>\n<p>To get there, I think that at some point we all need to stop caring about beautiful code. In that sense, normalisation tools like <a href=\"https://prettier.io\">Prettier</a> were in my opinion one of the biggest leaps that we've made in the recent years, because they enabled us not to focus our energy on <strong>what</strong> by-products.</p>\n<p>Our job is about turning a <strong>vision</strong> into a <strong>reality</strong>.</p>\n<p>Code isn't an end in itself. That's why I strongly believe in <strong>dumb code</strong>.</p>\n<h2>What's &quot;dumb code&quot;?</h2>\n<p>What I call <strong>dumb code</strong> is code that's:</p>\n<ul>\n<li><strong>easy to read</strong>: so that your teammates (or future you) can get it simply</li>\n<li><strong>explicit</strong>: it doesn't matter if your variable or function name is super-long. Don't put in a comment what you can put in a name.</li>\n<li><strong>honest</strong>: do <strong>not</strong> hide business complexity to fake simplicity. The only thing you'll accomplish is making people go to more places to grasp the ideas.</li>\n<li><strong>deletable</strong>: so that you don't get to the situation where nobody dares touching a piece of the program, not knowing if it'll break something</li>\n</ul>\n<p>To take a trivial example: in our front-end React codebase at BeOp, we do what's called <strong>props-drilling</strong>, which means that we pass down all the data from the root components down through props. I used to find that ugly. Today, some folks would still fight against that, arguing that it doesn't <strong>look clean</strong>, that we'd better <strong>use a separate data store</strong>.</p>\n<p>Sure. It's dumb.</p>\n<p>It's the dumbest way to pass data from a component to its descendants. <strong>That's also the simplest</strong>. Anyone who's worked on a React codebase knows how to pass a prop to a component. Anyone who reads a component source knows <strong>exactly</strong> what data it needs in seconds. If we used a data store, that person would probably need to go back and forth between 3 or 4 files just to figure out what happens.</p>\n<p>When you write <strong>smart code</strong>, the most likely person you'll outsmart is your future self, when coming back to that <em>very clever</em> piece of code that you don't remember and that you'll spend a few hours figuring out.</p>\n<p>If a piece of code that you don't find perfect brings immediate value to your product, why wouldn't you add it?</p>\n<p><img src=\"/public/assets/images/EffortValue.png\" alt=\"Effort on value\" /></p>\n<p><strong>Dumb code mecanically reduces the</strong> immediate and later <strong>effort</strong>, making the the value that you're able to bring more accessible.</p>\n<p>If we were code writing machines, we wouldn't bring much to the table.</p>\n<p>We're good when we take a step back and get the big picture.</p>\n<div style=\"font-size: 32px; text-align: center;\">\n  <strong>Make smart plans.</strong><br>\n  <strong>Write dumb code.</strong>\n</div>"}