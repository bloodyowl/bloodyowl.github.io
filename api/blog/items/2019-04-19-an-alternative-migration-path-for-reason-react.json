{"slug":"2019-04-19-an-alternative-migration-path-for-reason-react","filename":"2019-04-19-an-alternative-migration-path-for-reason-react","title":"An alternative migration path for ReasonReact","date":"Fri, 19 Apr 2019 00:00:00 GMT","draft":false,"meta":{"date":"2019-04-19T00:00:00.000Z","title":"An alternative migration path for ReasonReact"},"body":"<p><a href=\"https://github.com/bloodyowl/upgrade-reason-react-esy\">tl;dr</a></p>\n<h2>Why the new API?</h2>\n<p>ReasonReact 0.7.0 came out recently, with a really nice set of features:</p>\n<ul>\n<li>A closer model from the official ReactJS API</li>\n<li>Hooks</li>\n<li>Zero-cost bindings</li>\n</ul>\n<p>From some time now though, ReasonReact leverages function <strong>named parameters</strong> which provides a really nice set of features natively, such as defaults, optional parameters and ability to pattern match values.</p>\n<p>This was possible through a JSX transformation and some bindings that would apply these arguments at call site, and return a new version of the component whenever called.</p>\n<p>A component would look like this:</p>\n<pre><code class=\"language-reason\"><span class=\"hljs-comment\">/* MyComp.re */</span>\n<span class=\"hljs-keyword\">let</span> make = (~param1, ~param2, children) =&gt; {\n  <span class=\"hljs-operator\">...</span>component,\n  render: _ =&gt; &lt;div /&gt;\n};\n</code></pre>\n<p>And the call site <code>&lt;MyComp param1 param2 /&gt;</code> would desugar to something like this:</p>\n<pre><code class=\"language-reason\"><span class=\"hljs-module-identifier\">React</span>.element(~key, ~ref, <span class=\"hljs-module-identifier\">MyComp</span>.make(~param1, ~param2, <span class=\"hljs-literal\">[|</span><span class=\"hljs-literal\">|]</span> <span class=\"hljs-comment\">/* children*/</span>))\n</code></pre>\n<p>and would reuse the previous component through some magic in <code>React.element</code>, by keeping a reference to an actual React component class that'd render using the component spec it received.</p>\n<p>This magic worked while relying on the class-based API, because it wouldn't matter that the <code>make</code> function had a different identity at each run, as <code>React.createElement</code> effectively received class.</p>\n<p>With function component though, the story is a little different: <strong>function identity matters</strong> here. It'd be possible to wrap every component with a higher order one, but that wouldn't make for a good developer experience, and would possibly be a little heavier to run.</p>\n<p>The obvious choice would then be to start using directly the JS Object as props, just like in ReactJS. However, that wouldn't let us benefit from the really nice features function params give us (defaults, optionals, pattern matchingâ€¦).</p>\n<p>Therefore was introduced the <code>[@react.component]</code> attribute. What it does in summary:</p>\n<pre><code class=\"language-reason\"><span class=\"hljs-attribute\">[@react.component]</span>\n<span class=\"hljs-keyword\">let</span> make = (~prop1, ~prop2, ()) =&gt; {\n  &lt;div /&gt;\n};\n</code></pre>\n<p>is that it leverages <code>[@bs.obj]</code> (zero-cost except in edge-cases) and roughly generates the following:</p>\n<pre><code class=\"language-reason\"><span class=\"hljs-keyword\">let</span> makeProps: (~prop1, ~prop2, unit) =&gt;\n  {. <span class=\"hljs-string\">&quot;prop1&quot;</span>: &#x27;a, <span class=\"hljs-string\">&quot;prop2&quot;</span>: &#x27;b};\n\n<span class=\"hljs-keyword\">let</span> make: ({. <span class=\"hljs-string\">&quot;prop1&quot;</span>: &#x27;a, <span class=\"hljs-string\">&quot;prop2&quot;</span>: &#x27;b}) =&gt;\n  <span class=\"hljs-module-identifier\">React</span>.element;\n</code></pre>\n<p>This way, the new JSX API can simply desugar to:</p>\n<pre><code class=\"language-reason\"><span class=\"hljs-module-identifier\">React</span>.createElement(<span class=\"hljs-module-identifier\">MyComp</span>.make, <span class=\"hljs-module-identifier\">MyComp</span>.makeProps(~prop1, ~prop2, ()));\n</code></pre>\n<p>which is, thanks to BuckleScript, compiled to:</p>\n<pre><code class=\"language-js\">React.createElement(MyComp.make, { <span class=\"hljs-attr\">prop1</span>: prop1, <span class=\"hljs-attr\">prop2</span>: prop2 });\n</code></pre>\n<h2>Planning the migration</h2>\n<p>Of course, changing the way JSX works must have been a tough call for the ReasonReact team, as the API has been pretty stable for some time before that, but I'm sure the benefits in the long run will be really important.</p>\n<p>Now, how do we handle the transition?</p>\n<p>The original plan <a href=\"https://twitter.com/rickyvetter\">Ricky Vetter</a> had was to create a hook that'd wrap the old component specs and act as a compatibility API. In the end, he assessed that this way wouldn't be able to provide a script that'd be safe enough for people to use and provided a different kind of migration path.</p>\n<p>I really found the idea to be elegant though, and if I ever released it and it was a bit rough around the edges, people wouldn't be as mad as they would've been with an official migration.</p>\n<p>So I went on from Ricky's work, patched a few things and made <a href=\"https://github.com/bloodyowl/reason-react-compat\">reason-react-compat</a>. The main concept is that it replicates the lifecycle using hooks. It has of course some small issues, such as retriggering a render each time you send a side-effect and might be a little aggressive on <code>willReceiveProps</code> (treat it as it was <code>getDerivedStateFromProps</code>). Other than that it should mostly work, and these are tradeoffs I'm personnaly willing to make for my own codebase.</p>\n<p>After having that, I wanted to make an automated codemod, and ended up with the following list of what it needed to do (lots of points here are motivated by how my internal codebase is made):</p>\n<ul>\n<li>Add <code>[@react.component]</code> to <code>make</code> functions returning a <code>component</code> in implementation</li>\n<li>Wrap these components with <code>ReactCompat.useRecordApi</code></li>\n<li>Turn ignored <code>children</code> (starting with <code>_</code>) to <code>unit</code> in implementation</li>\n<li>Turn used <code>children</code> into a named parameter and append a <code>unit</code> parameter in implementation</li>\n<li>Use <code>React.Children.toArray</code> at the top of every make function's body that use them as such (children type isn't guaranteed to be <code>array(React.element)</code> anymore)</li>\n<li>Add <code>[@react.component]</code> to <code>make</code> functions returning a <code>component</code> in interfaces</li>\n<li>Turn <code>array(React.element)</code> into <code>React.element</code> for children in interfaces</li>\n<li>Turn <code>React.component(a, b, c)</code> and <code>React.componentSpec(a, a, b, b, c, c)</code> into <code>React.element</code> in interfaces' <code>make</code> return value</li>\n<li>Handle all of the above for nested modules and functors</li>\n</ul>\n<p>So I forked Cheng Lou's <a href=\"https://github.com/chenglou/upgrade-reason-react\">upgrade-reason-react</a> and started working with the AST (it's really fun, you should try it!) and ended up with a decent transformation (at least for my test cases). If you're interested, <a href=\"https://github.com/bloodyowl/upgrade-reason-react-esy\">the above transformation script is available on GitHub</a>, you can check the input in <code>test/cases</code> and output in <code>output/test/cases</code>.</p>\n<p>While I was at it, I also released a <code>useReducer</code> hook that allows returning an update (<code>NoUpdate</code>, <code>Update</code>, <code>UpdateWithSideEffects</code> or <code>SideEffects</code>) because I find that to be <a href=\"/blog/2019-01-24-orchestrating-requests-at-component-level/\">one of the best way to orchestrate things in your components</a>, you can check it out in <a href=\"https://github.com/bloodyowl/reason-react-update\">its repository</a>.</p>\n<p>If you want to try these, be sure to ping me in Twitter, Discord or GitHub if you run into any issue!</p>\n"}